// FSM for RX handshake snchronizer
module receiver_fsm(
   input   logic dest_clk, dest_reset, // posedge dest_clk and asynchronous posedge dest_reset
   input   logic req_i, // req_i = 1 generated by tx_fsm indicating to receiver_fsm new data req_iuest is available. Also indicating start of 4-phase handshake
                        // req_i = 0 generated by tx_fsm indicating to receiver_fsm that is has transmitted current data or there is no new data to be transmitted
   output  logic ack_o, // ack_o = 1 sent by receiver_fsm to tx_fsm, indicating that it is ack_onowleding the the req_iuest for new data
                        // ack_o = 0 sent by receiver_fsm to tx_fsm, indicating that receiver_fsm has received the new data. Also indicating end of 4-phase handshake.
   output  logic data_in_en // data_in_en = 1 generated by receiver_fsm to enable loading of the incoming data from tx_fsm in destination register
                              // data_in_en = 0 generated by receiver_fsm to disable loading of the incoming data from tx_fsm in destination register
);

// state encoding and state variable
enum logic{
   ACK_REQ_PHASE1  = 1'b0, // FSM state to assert ack_o = 0, data_in_en = 0 and wait for req_i = 1
   ACK_REQ_PHASE2  = 1'b1  // FSM state to assert ack_o = 1, data_in_en = 1 and wait for req_i = 0
} state;


// FSM with single always block for next state, 
// present state flipflop and output logic 
always_ff@(posedge dest_clk, posedge dest_reset) begin
   if(dest_reset) begin
      ack_o <= 0;
      data_in_en <= 0;
      state <= ACK_REQ_PHASE1;
   end   
   else begin
      case(state)
         
         // 代表:Sender_fsm haven't recieve req_i
			// = IDLE state of receiver_fsm
         // enable loading of data in the data register
         ACK_REQ_PHASE1: begin
				ack_o <= 0;
				data_in_en <= 0;
				
				if(req_i == 1)begin
					state <= ACK_REQ_PHASE2;
				end
				else begin
					state <= ACK_REQ_PHASE1;
				end
         end
         
         // 代表:Sender_fsm recieved req_i
         // loading of data in destination register and then wait for req_i = 0
         ACK_REQ_PHASE2: begin
				ack_o <= 1;
				data_in_en <= 1;
				
				if(req_i == 0)begin
					state <= ACK_REQ_PHASE1;
				end
				else begin
					state <= ACK_REQ_PHASE2;
				end
         end
         
         // In Default state move to IDLE state    
         default: begin
            state <= ACK_REQ_PHASE1;
         end
      endcase
   end
end

endmodule: receiver_fsm

